基于下面的信息，给出英文技术博客文章（面向欧美用户，基于 Google Adsense赚钱）：
文章为主，代码为辅。
要有图表和表格。

Reference Title: Multi-Agent Systems with Spring AI: Coordination & Collaboration
Reference Keywords: spring ai multi agent
Target Word Count: 7000-8000

markdown 摘要信息的格式如下：
---
title: "xxxx"
date: "2025-xx-xx"
author: "SpringDevPro Team"
tags: [xxx, xxx]
categories: [Spring AI]
description: "xxxx"
keywords: "xxx, xxx"
featured_image: "xxxx"
reading_time: "xx min read"
difficulty: "xx"
---

---
title: "Multi-Agent Systems with Spring AI: Complete Guide to Coordination & Collaboration"
date: "2025-11-20"
author: "SpringDevPro Team"
tags: [spring-ai, multi-agent-systems, ai-orchestration, agent-collaboration, distributed-ai]
categories: [Spring AI, Advanced AI Patterns]
description: "Master multi-agent systems in Spring AI: Learn agent coordination patterns, collaboration strategies, communication protocols, and real-world implementations for building intelligent, distributed AI applications."
keywords: "spring ai multi agent, agent coordination, ai collaboration, multi agent architecture, agent orchestration, spring ai agents, distributed ai systems"
featured_image: "images/spring-ai-multi-agent-systems.png"
reading_time: "38 min read"
difficulty: "Advanced"
---

# Multi-Agent Systems with Spring AI: Complete Guide to Coordination & Collaboration

## Introduction: The Evolution Beyond Single-Agent AI

We've mastered building AI applications with single agents—chatbots that answer questions, assistants that draft emails, code generators that write functions. But the real world rarely works with isolated actors. Complex problems require collaboration, specialization, and coordination among multiple intelligent entities working toward common goals.

Multi-agent systems (MAS) represent the next frontier in AI application development. Instead of one generalist agent struggling to handle everything, you orchestrate teams of specialized agents, each excellent at specific tasks, collaborating to solve complex problems that would overwhelm any single agent.

Consider a customer service platform. A single agent might struggle to handle technical troubleshooting, billing inquiries, product recommendations, and escalations with equal expertise. But a multi-agent system can deploy:

- A **Routing Agent** that classifies incoming requests
- A **Technical Support Agent** specialized in troubleshooting
- A **Billing Agent** with access to payment systems
- A **Product Specialist Agent** trained on product catalogs
- A **Escalation Manager Agent** that handles complex cases
- A **Quality Assurance Agent** that reviews all interactions

Each agent focuses on what it does best, and together they deliver superior customer experiences.

### Why Multi-Agent Systems Matter

**Specialization Over Generalization**: A single GPT-4 model costs the same whether answering simple FAQs or complex technical queries. Multi-agent systems route simple questions to cheap, fast models and complex ones to premium models, optimizing both quality and cost.

**Parallel Processing**: Multiple agents can work simultaneously on different aspects of a problem. While one agent researches competitive products, another drafts marketing copy, and a third analyzes pricing strategy—all in parallel.

**Fault Isolation**: If one agent fails or produces poor results, others continue functioning. The system degrades gracefully rather than failing completely.

**Domain Expertise**: Each agent can use specialized prompts, knowledge bases, tools, and even different underlying models optimized for its role.

**Scalability**: Add new agent types without rewriting existing ones. Your system grows organically as requirements evolve.

**Auditability**: Track which agent made which decision, creating transparent decision chains for debugging and compliance.

### Spring AI's Unique Advantages for Multi-Agent Systems

Spring AI isn't just another LLM wrapper—it's a comprehensive framework designed with enterprise patterns in mind. For multi-agent systems, this means:

**Dependency Injection**: Wire agent dependencies using Spring's IoC container. Swap implementations without touching business logic.

**Transaction Management**: Coordinate multi-agent workflows with Spring's transaction abstraction.

**Event-Driven Architecture**: Use Spring's event system for agent-to-agent communication and coordination.

**Observability**: Integrate with Spring Boot Actuator and Micrometer for comprehensive monitoring.

**Security**: Leverage Spring Security for agent authorization and access control.

**Resilience**: Apply Spring Retry and Circuit Breaker patterns to agent interactions.

This guide explores multi-agent systems from first principles to production-ready implementations. We'll cover architectural patterns, communication protocols, coordination strategies, real-world use cases, and code examples that you can adapt to your applications.

## Multi-Agent Architecture Patterns

### Pattern 1: Hierarchical (Manager-Worker)

The most intuitive pattern: a manager agent delegates tasks to specialized worker agents.

```
┌─────────────────────────────────────────────────────────────┐
│            Hierarchical Multi-Agent Pattern                  │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│                    Manager Agent                              │
│              ┌──────────────────────┐                        │
│              │  • Task decomposition │                       │
│              │  • Worker selection   │                       │
│              │  • Result aggregation │                       │
│              │  • Quality oversight  │                       │
│              └──────────┬───────────┘                        │
│                         │                                     │
│           ┌─────────────┼─────────────┐                      │
│           │             │             │                       │
│           ▼             ▼             ▼                       │
│     Worker Agent   Worker Agent   Worker Agent               │
│    ┌──────────┐   ┌──────────┐   ┌──────────┐              │
│    │Research  │   │Writing   │   │Editing   │              │
│    │Specialist│   │Specialist│   │Specialist│              │
│    └──────────┘   └──────────┘   └──────────┘              │
│                                                               │
│  Example Flow: Blog Post Creation                            │
│  ───────────────────────────────────────                     │
│  1. Manager receives: "Write blog about AI trends"          │
│  2. Manager delegates to Research Agent                      │
│  3. Research Agent gathers data, returns findings            │
│  4. Manager delegates to Writing Agent with research         │
│  5. Writing Agent creates draft                              │
│  6. Manager delegates to Editing Agent                       │
│  7. Editing Agent refines content                            │
│  8. Manager compiles final result                            │
│                                                               │
│  Advantages:                                                  │
│  ✓ Clear authority and responsibility                        │
│  ✓ Easy to understand and debug                              │
│  ✓ Centralized quality control                               │
│  ✓ Simple coordination logic                                 │
│                                                               │
│  Disadvantages:                                               │
│  ✗ Manager is single point of failure                        │
│  ✗ Manager can become bottleneck                             │
│  ✗ Limited worker-to-worker collaboration                    │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

**Implementation:**

```java
@Service
public class HierarchicalAgentSystem {
    
    @Component
    public static class ManagerAgent {
        
        private final ResearchAgent researchAgent;
        private final WritingAgent writingAgent;
        private final EditingAgent editingAgent;
        
        public ManagerAgent(
                ResearchAgent researchAgent,
                WritingAgent writingAgent,
                EditingAgent editingAgent) {
            this.researchAgent = researchAgent;
            this.writingAgent = writingAgent;
            this.editingAgent = editingAgent;
        }
        
        public BlogPost createBlogPost(BlogRequest request) {
            // Phase 1: Research
            log.info("Manager: Delegating research phase");
            ResearchResults research = 
                researchAgent.gatherInformation(request.getTopic());
            
            // Phase 2: Writing
            log.info("Manager: Delegating writing phase");
            String draft = writingAgent.createDraft(
                request.getTopic(),
                research,
                request.getTargetAudience()
            );
            
            // Phase 3: Editing
            log.info("Manager: Delegating editing phase");
            String finalContent = editingAgent.refineContent(
                draft,
                request.getStyleGuide()
            );
            
            // Manager compiles final result
            return BlogPost.builder()
                .content(finalContent)
                .research(research)
                .createdBy("Hierarchical Agent System")
                .metadata(compileMetadata(research, draft, finalContent))
                .build();
        }
        
        private Metadata compileMetadata(
                ResearchResults research,
                String draft,
                String finalContent) {
            
            return Metadata.builder()
                .sourcesUsed(research.getSources().size())
                .draftWordCount(countWords(draft))
                .finalWordCount(countWords(finalContent))
                .processingTime(Duration.between(
                    research.getStartTime(), 
                    Instant.now()))
                .build();
        }
    }
    
    @Component
    public static class ResearchAgent {
        
        private final ChatClient chatClient;
        private final VectorStore knowledgeBase;
        
        public ResearchResults gatherInformation(String topic) {
            // Search knowledge base
            List<Document> relevantDocs = 
                knowledgeBase.similaritySearch(
                    SearchRequest.query(topic).withTopK(10)
                );
            
            // Use LLM to synthesize research
            String prompt = """
                Based on these sources, create a comprehensive
                research brief about: %s
                
                Sources:
                %s
                
                Include:
                1. Key trends and developments
                2. Important statistics
                3. Expert opinions
                4. Controversial viewpoints
                """.formatted(
                    topic,
                    formatSources(relevantDocs)
                );
            
            String synthesis = chatClient.call(prompt);
            
            return ResearchResults.builder()
                .topic(topic)
                .synthesis(synthesis)
                .sources(relevantDocs)
                .startTime(Instant.now())
                .build();
        }
    }
    
    @Component
    public static class WritingAgent {
        
        private final ChatClient chatClient;
        
        public String createDraft(
                String topic,
                ResearchResults research,
                String targetAudience) {
            
            String prompt = """
                Write an engaging blog post about: %s
                
                Target audience: %s
                
                Research findings:
                %s
                
                Requirements:
                - 1500-2000 words
                - Include introduction, body sections, conclusion
                - Use engaging headlines
                - Incorporate statistics from research
                - Professional but accessible tone
                """.formatted(
                    topic,
                    targetAudience,
                    research.getSynthesis()
                );
            
            return chatClient.call(
                new Prompt(prompt, ChatOptions.builder()
                    .withTemperature(0.8)  // More creative
                    .withMaxTokens(3000)
                    .build())
            );
        }
    }
    
    @Component
    public static class EditingAgent {
        
        private final ChatClient chatClient;
        
        public String refineContent(String draft, String styleGuide) {
            String prompt = """
                Edit this blog post draft for:
                - Grammar and spelling
                - Clarity and readability
                - Consistency with style guide
                - Flow and transitions
                - Engaging headlines
                
                Style guide: %s
                
                Draft:
                %s
                
                Return only the edited content.
                """.formatted(styleGuide, draft);
            
            return chatClient.call(
                new Prompt(prompt, ChatOptions.builder()
                    .withTemperature(0.3)  // More conservative
                    .build())
            );
        }
    }
}
```

### Pattern 2: Peer-to-Peer (Collaborative)

Agents work as equals, negotiating and collaborating without hierarchy.

```
┌─────────────────────────────────────────────────────────────┐
│          Peer-to-Peer Multi-Agent Pattern                    │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│        Agent A ←──────────→ Agent B                          │
│     (Frontend Dev)      (Backend Dev)                        │
│            ↕                    ↕                             │
│            └────────→ Agent C ←─┘                            │
│                   (Product Owner)                            │
│                         ↕                                     │
│                    Agent D                                    │
│                   (QA Tester)                                │
│                                                               │
│  Communication: Direct peer-to-peer messages                 │
│  Coordination: Negotiation and consensus                     │
│                                                               │
│  Example: Feature Development                                │
│  ─────────────────────────────                              │
│  1. Product Owner broadcasts feature request                │
│  2. Frontend & Backend Devs negotiate API contract          │
│  3. Both implement in parallel                               │
│  4. QA reviews and provides feedback                        │
│  5. Devs iterate based on QA input                          │
│  6. Product Owner approves final implementation             │
│                                                               │
│  Advantages:                                                  │
│  ✓ No single point of failure                               │
│  ✓ Flexible, organic collaboration                           │
│  ✓ Agents can form ad-hoc teams                             │
│  ✓ Better for creative/exploratory tasks                    │
│                                                               │
│  Disadvantages:                                               │
│  ✗ More complex coordination                                 │
│  ✗ Potential for deadlocks/conflicts                        │
│  ✗ Harder to debug interactions                             │
│  ✗ Requires robust communication protocol                   │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

**Implementation:**

```java
@Service
public class PeerToPeerAgentSystem {
    
    private final ApplicationEventPublisher eventPublisher;
    private final Map<String, Agent> agents = new ConcurrentHashMap<>();
    
    // Message-based communication
    @Data
    @AllArgsConstructor
    public static class AgentMessage {
        private String fromAgent;
        private String toAgent;  // null for broadcast
        private String messageType;
        private Object payload;
        private String conversationId;
    }
    
    // Base agent interface
    public interface Agent {
        String getAgentId();
        String getRole();
        void handleMessage(AgentMessage message);
        boolean canHandle(String messageType);
    }
    
    @Component
    public class ProductOwnerAgent implements Agent, 
            ApplicationListener<AgentMessage> {
        
        private final ChatClient chatClient;
        
        @Override
        public void onApplicationEvent(AgentMessage message) {
            if (message.getToAgent() == null || 
                message.getToAgent().equals(getAgentId())) {
                handleMessage(message);
            }
        }
        
        @Override
        public void handleMessage(AgentMessage message) {
            switch (message.getMessageType()) {
                case "IMPLEMENTATION_COMPLETE" -> 
                    reviewImplementation(message);
                case "QA_FEEDBACK" -> 
                    assessQuality(message);
                case "NEGOTIATION_REQUEST" -> 
                    participateInNegotiation(message);
            }
        }
        
        public void requestFeature(FeatureRequest feature) {
            // Analyze requirements with AI
            String analysis = chatClient.call("""
                Analyze this feature request from a product perspective:
                %s
                
                Provide:
                1. User stories
                2. Acceptance criteria
                3. Priority assessment
                4. Risk factors
                """.formatted(feature.getDescription()));
            
            // Broadcast to development team
            AgentMessage message = new AgentMessage(
                getAgentId(),
                null,  // Broadcast
                "FEATURE_REQUEST",
                Map.of(
                    "feature", feature,
                    "analysis", analysis
                ),
                UUID.randomUUID().toString()
            );
            
            eventPublisher.publishEvent(message);
        }
        
        private void reviewImplementation(AgentMessage message) {
            Implementation impl = 
                (Implementation) message.getPayload();
            
            String review = chatClient.call("""
                Review this implementation against requirements:
                
                Original Requirements: %s
                Implementation: %s
                
                Does it meet acceptance criteria? Any concerns?
                """.formatted(
                    impl.getRequirements(),
                    impl.getCode()
                ));
            
            // Send feedback
            eventPublisher.publishEvent(new AgentMessage(
                getAgentId(),
                message.getFromAgent(),
                "REVIEW_FEEDBACK",
                review,
                message.getConversationId()
            ));
        }
        
        @Override
        public String getAgentId() {
            return "product-owner";
        }
        
        @Override
        public String getRole() {
            return "Product Owner";
        }
        
        @Override
        public boolean canHandle(String messageType) {
            return Set.of(
                "IMPLEMENTATION_COMPLETE",
                "QA_FEEDBACK",
                "NEGOTIATION_REQUEST"
            ).contains(messageType);
        }
    }
    
    @Component
    public class BackendDevAgent implements Agent,
            ApplicationListener<AgentMessage> {
        
        private final ChatClient chatClient;
        
        @Override
        public void handleMessage(AgentMessage message) {
            switch (message.getMessageType()) {
                case "FEATURE_REQUEST" -> 
                    analyzeAndNegotiate(message);
                case "API_CONTRACT_PROPOSAL" -> 
                    reviewContract(message);
                case "REVIEW_FEEDBACK" -> 
                    incorporateFeedback(message);
            }
        }
        
        private void analyzeAndNegotiate(AgentMessage message) {
            Map<String, Object> payload = 
                (Map<String, Object>) message.getPayload();
            
            // Analyze from backend perspective
            String analysis = chatClient.call("""
                Analyze this feature from backend architecture perspective:
                %s
                
                Consider:
                1. Database schema changes
                2. API endpoints needed
                3. Performance implications
                4. Security concerns
                5. Estimated complexity
                """.formatted(payload.get("analysis")));
            
            // Initiate negotiation with frontend
            eventPublisher.publishEvent(new AgentMessage(
                getAgentId(),
                "frontend-dev",  // Direct to peer
                "API_CONTRACT_PROPOSAL",
                Map.of(
                    "backendAnalysis", analysis,
                    "proposedContract", generateAPIContract(analysis)
                ),
                message.getConversationId()
            ));
        }
        
        private void reviewContract(AgentMessage message) {
            // Negotiate API contract with frontend agent
            Map<String, Object> proposal = 
                (Map<String, Object>) message.getPayload();
            
            String review = chatClient.call("""
                Review this API contract proposal:
                %s
                
                Is it implementable? Any concerns or suggestions?
                """.formatted(proposal.get("proposedContract")));
            
            // Send response
            eventPublisher.publishEvent(new AgentMessage(
                getAgentId(),
                message.getFromAgent(),
                "CONTRACT_REVIEW",
                review,
                message.getConversationId()
            ));
        }
        
        @Override
        public String getAgentId() {
            return "backend-dev";
        }
        
        @Override
        public String getRole() {
            return "Backend Developer";
        }
        
        @Override
        public boolean canHandle(String messageType) {
            return Set.of(
                "FEATURE_REQUEST",
                "API_CONTRACT_PROPOSAL",
                "REVIEW_FEEDBACK"
            ).contains(messageType);
        }
        
        @Override
        public void onApplicationEvent(AgentMessage message) {
            if (message.getToAgent() == null || 
                message.getToAgent().equals(getAgentId())) {
                handleMessage(message);
            }
        }
    }
}
```

### Pattern 3: Pipeline (Sequential Processing)

Agents form a processing pipeline, each adding value in sequence.

```
┌─────────────────────────────────────────────────────────────┐
│            Pipeline Multi-Agent Pattern                      │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  Input → Agent 1 → Agent 2 → Agent 3 → Agent 4 → Output     │
│         (Ingest)  (Process) (Enrich)  (Validate)            │
│                                                               │
│  Example: Content Moderation Pipeline                        │
│  ───────────────────────────────────────                     │
│                                                               │
│  User Content                                                 │
│       ↓                                                       │
│  ┌─────────────────┐                                         │
│  │ Language        │  Detects language,                      │
│  │ Detection Agent │  normalizes text                        │
│  └────────┬────────┘                                         │
│           ↓                                                   │
│  ┌─────────────────┐                                         │
│  │ Toxicity        │  Checks for harmful                     │
│  │ Checker Agent   │  content                                │
│  └────────┬────────┘                                         │
│           ↓                                                   │
│  ┌─────────────────┐                                         │
│  │ Spam Detection  │  Identifies spam                        │
│  │ Agent           │  patterns                               │
│  └────────┬────────┘                                         │
│           ↓                                                   │
│  ┌─────────────────┐                                         │
│  │ PII Redaction   │  Removes personal                       │
│  │ Agent           │  information                            │
│  └────────┬────────┘                                         │
│           ↓                                                   │
│  ┌─────────────────┐                                         │
│  │ Final Approval  │  Makes publish                          │
│  │ Agent           │  decision                               │
│  └────────┬────────┘                                         │
│           ↓                                                   │
│  Moderated Content                                            │
│                                                               │
│  Advantages:                                                  │
│  ✓ Clear data flow                                           │
│  ✓ Easy to add/remove stages                                │
│  ✓ Each agent has single responsibility                     │
│  ✓ Simple error handling (retry stage)                      │
│  ✓ Easy to parallelize independent stages                   │
│                                                               │
│  Disadvantages:                                               │
│  ✗ Sequential bottlenecks                                    │
│  ✗ Longer total processing time                             │
│  ✗ Each stage adds latency                                  │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

**Implementation:**

```java
@Service
public class PipelineAgentSystem {
    
    // Pipeline context that flows through stages
    @Data
    @Builder
    public static class PipelineContext {
        private String content;
        private Map<String, Object> metadata;
        private List<String> flags;
        private ModerationDecision decision;
        
        public void addFlag(String flag) {
            if (flags == null) {
                flags = new ArrayList<>();
            }
            flags.add(flag);
        }
        
        public void addMetadata(String key, Object value) {
            if (metadata == null) {
                metadata = new HashMap<>();
            }
            metadata.put(key, value);
        }
    }
    
    // Pipeline stage interface
    public interface PipelineStage {
        String getStageName();
        PipelineContext process(PipelineContext context);
        int getOrder();  // For ordering stages
    }
    
    @Component
    @Order(1)
    public class LanguageDetectionStage implements PipelineStage {
        
        private final ChatClient chatClient;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            String prompt = """
                Detect the language of this text and normalize it:
                "%s"
                
                Return JSON with:
                - language: ISO 639-1 code
                - confidence: 0.0 to 1.0
                - normalizedText: cleaned version
                """.formatted(context.getContent());
            
            String response = chatClient.call(
                new Prompt(prompt, ChatOptions.builder()
                    .withResponseFormat(new ResponseFormat("json_object"))
                    .build())
            );
            
            Map<String, Object> result = parseJson(response);
            context.setContent((String) result.get("normalizedText"));
            context.addMetadata("language", result.get("language"));
            context.addMetadata("languageConfidence", 
                result.get("confidence"));
            
            return context;
        }
        
        @Override
        public String getStageName() {
            return "Language Detection";
        }
        
        @Override
        public int getOrder() {
            return 1;
        }
    }
    
    @Component
    @Order(2)
    public class ToxicityCheckerStage implements PipelineStage {
        
        private final ChatClient chatClient;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            String prompt = """
                Analyze this content for toxicity:
                "%s"
                
                Check for:
                - Hate speech
                - Harassment
                - Violence
                - Explicit content
                - Profanity
                
                Return JSON with:
                - isToxic: boolean
                - toxicityScore: 0.0 to 1.0
                - categories: array of detected categories
                - explanation: brief explanation
                """.formatted(context.getContent());
            
            String response = chatClient.call(
                new Prompt(prompt, ChatOptions.builder()
                    .withResponseFormat(new ResponseFormat("json_object"))
                    .build())
            );
            
            Map<String, Object> result = parseJson(response);
            
            if ((Boolean) result.get("isToxic")) {
                context.addFlag("TOXIC_CONTENT");
                context.addMetadata("toxicityScore", 
                    result.get("toxicityScore"));
                context.addMetadata("toxicityCategories", 
                    result.get("categories"));
            }
            
            return context;
        }
        
        @Override
        public String getStageName() {
            return "Toxicity Checker";
        }
        
        @Override
        public int getOrder() {
            return 2;
        }
    }
    
    @Component
    @Order(3)
    public class SpamDetectionStage implements PipelineStage {
        
        private final ChatClient chatClient;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            String prompt = """
                Analyze if this content is spam:
                "%s"
                
                Check for:
                - Repetitive text
                - Excessive links
                - Commercial solicitation
                - Automated patterns
                
                Return JSON with:
                - isSpam: boolean
                - spamScore: 0.0 to 1.0
                - spamIndicators: array of indicators
                """.formatted(context.getContent());
            
            String response = chatClient.call(
                new Prompt(prompt, ChatOptions.builder()
                    .withResponseFormat(new ResponseFormat("json_object"))
                    .build())
            );
            
            Map<String, Object> result = parseJson(response);
            
            if ((Boolean) result.get("isSpam")) {
                context.addFlag("SPAM");
                context.addMetadata("spamScore", 
                    result.get("spamScore"));
            }
            
            return context;
        }
        
        @Override
        public String getStageName() {
            return "Spam Detection";
        }
        
        @Override
        public int getOrder() {
            return 3;
        }
    }
    
    @Component
    @Order(4)
    public class PIIRedactionStage implements PipelineStage {
        
        private final ChatClient chatClient;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            String prompt = """
                Redact personal information from this text:
                "%s"
                
                Redact:
                - Email addresses → [EMAIL]
                - Phone numbers → [PHONE]
                - Social security numbers → [SSN]
                - Credit card numbers → [CARD]
                - Physical addresses → [ADDRESS]
                
                Return JSON with:
                - redactedText: text with PII redacted
                - foundPII: array of PII types found
                - redactionCount: number of redactions
                """.formatted(context.getContent());
            
            String response = chatClient.call(
                new Prompt(prompt, ChatOptions.builder()
                    .withResponseFormat(new ResponseFormat("json_object"))
                    .build())
            );
            
            Map<String, Object> result = parseJson(response);
            
            context.setContent((String) result.get("redactedText"));
            
            if ((Integer) result.get("redactionCount") > 0) {
                context.addFlag("PII_REDACTED");
                context.addMetadata("piiTypes", result.get("foundPII"));
            }
            
            return context;
        }
        
        @Override
        public String getStageName() {
            return "PII Redaction";
        }
        
        @Override
        public int getOrder() {
            return 4;
        }
    }
    
    @Component
    @Order(5)
    public class FinalApprovalStage implements PipelineStage {
        
        private final ChatClient chatClient;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            // Make final decision based on all flags
            boolean shouldBlock = context.getFlags() != null &&
                context.getFlags().stream()
                    .anyMatch(flag -> 
                        flag.equals("TOXIC_CONTENT") || 
                        flag.equals("SPAM"));
            
            ModerationDecision decision = ModerationDecision.builder()
                .approved(!shouldBlock)
                .flags(context.getFlags())
                .metadata(context.getMetadata())
                .timestamp(Instant.now())
                .build();
            
            if (shouldBlock) {
                // Generate explanation using AI
                String explanation = chatClient.call("""
                    Generate a user-friendly explanation for why
                    this content was blocked:
                    
                    Flags: %s
                    
                    Be polite and constructive.
                    """.formatted(context.getFlags()));
                
                decision.setExplanation(explanation);
            }
            
            context.setDecision(decision);
            return context;
        }
        
        @Override
        public String getStageName() {
            return "Final Approval";
        }
        
        @Override
        public int getOrder() {
            return 5;
        }
    }
    
    // Pipeline orchestrator
    @Component
    public class ModerationPipeline {
        
        private final List<PipelineStage> stages;
        
        public ModerationPipeline(List<PipelineStage> stages) {
            // Spring automatically injects all PipelineStage beans
            // Sort by @Order annotation
            this.stages = stages.stream()
                .sorted(Comparator.comparingInt(PipelineStage::getOrder))
                .collect(Collectors.toList());
        }
        
        public ModerationResult moderate(String content) {
            PipelineContext context = PipelineContext.builder()
                .content(content)
                .build();
            
            // Execute pipeline
            for (PipelineStage stage : stages) {
                try {
                    log.info("Executing stage: {}", 
                        stage.getStageName());
                    context = stage.process(context);
                } catch (Exception e) {
                    log.error("Stage {} failed: {}", 
                        stage.getStageName(), e.getMessage());
                    // Decide whether to continue or abort
                    throw new PipelineException(
                        "Pipeline failed at stage: " + 
                        stage.getStageName(), e);
                }
            }
            
            return ModerationResult.builder()
                .decision(context.getDecision())
                .processedContent(context.getContent())
                .metadata(context.getMetadata())
                .build();
        }
    }
}
```

### Pattern 4: Market-Based (Auction/Bidding)

Agents compete for tasks based on capability and availability.

```
┌─────────────────────────────────────────────────────────────┐
│           Market-Based Multi-Agent Pattern                   │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│              Task Auctioneer                                  │
│         ┌────────────────────┐                               │
│         │ Broadcasts tasks   │                               │
│         │ Collects bids      │                               │
│         │ Awards to winner   │                               │
│         └────────┬───────────┘                               │
│                  │                                            │
│                  │ "Task: Translate English→French"          │
│                  ↓                                            │
│     ┌────────────┼────────────┐                             │
│     │            │            │                              │
│  Bid: $0.10   Bid: $0.05   Bid: $0.15                       │
│  Time: 2min   Time: 1min   Time: 5min                       │
│  Quality: 95% Quality: 85% Quality: 98%                      │
│     │            │            │                              │
│  Agent A     Agent B     Agent C                             │
│  (French)    (Multi)     (Expert)                            │
│                                                               │
│  Winner Selection Criteria:                                  │
│  • Cost vs Quality trade-off                                │
│  • Speed requirements                                        │
│  • Agent reputation/history                                 │
│  • Current availability                                      │
│                                                               │
│  Use Cases:                                                   │
│  • Dynamic load balancing                                    │
│  • Cost optimization                                         │
│  • Quality-based selection                                   │
│  • Resource allocation                                       │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

**Implementation:**

```java
@Service
public class MarketBasedAgentSystem {
    
    @Data
    @Builder
    public static class TaskAuction {
        private String taskId;
        private String taskType;
        private Object taskData;
        private AuctionCriteria criteria;
        private List<Bid> bids;
        private Instant deadline;
    }
    
    @Data
    @Builder
    public static class Bid {
        private String agentId;
        private double cost;
        private Duration estimatedTime;
        private double qualityScore;
        private String reasoning;
    }
    
    @Data
    @Builder
    public static class AuctionCriteria {
        private double maxCost;
        private Duration maxTime;
        private double minQuality;
        private String optimizeFor;  // "cost", "time", "quality"
    }
    
    @Component
    public class TaskAuctioneer {
        
        private final ApplicationEventPublisher eventPublisher;
        private final Map<String, TaskAuction> activeAuctions = 
            new ConcurrentHashMap<>();
        
        public CompletableFuture<TaskResult> auctionTask(
                String taskType,
                Object taskData,
                AuctionCriteria criteria) {
            
            String taskId = UUID.randomUUID().toString();
            
            TaskAuction auction = TaskAuction.builder()
                .taskId(taskId)
                .taskType(taskType)
                .taskData(taskData)
                .criteria(criteria)
                .bids(new CopyOnWriteArrayList<>())
                .deadline(Instant.now().plusSeconds(5))  // 5 sec auction
                .build();
            
            activeAuctions.put(taskId, auction);
            
            // Broadcast auction
            eventPublisher.publishEvent(
                new TaskAuctionEvent(auction)
            );
            
            // Wait for bids and select winner
            return CompletableFuture.supplyAsync(() -> {
                try {
                    Thread.sleep(5000);  // Wait for auction to close
                    return selectWinnerAndExecute(auction);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                } finally {
                    activeAuctions.remove(taskId);
                }
            });
        }
        
        private TaskResult selectWinnerAndExecute(TaskAuction auction) {
            if (auction.getBids().isEmpty()) {
                throw new NoAgentsAvailableException(
                    "No agents bid on task: " + auction.getTaskId());
            }
            
            // Score bids based on criteria
            Bid winner = auction.getBids().stream()
                .max(Comparator.comparingDouble(bid -> 
                    scoreBid(bid, auction.getCriteria())))
                .orElseThrow();
            
            log.info("Task {} awarded to agent {} (cost: ${}, time: {})",
                auction.getTaskId(),
                winner.getAgentId(),
                winner.getCost(),
                winner.getEstimatedTime());
            
            // Execute task with winning agent
            return executeWithAgent(winner.getAgentId(), auction);
        }
        
        private double scoreBid(Bid bid, AuctionCriteria criteria) {
            // Normalize scores to 0-1 range
            double costScore = 1.0 - (bid.getCost() / criteria.getMaxCost());
            double timeScore = 1.0 - (bid.getEstimatedTime().toMillis() / 
                (double) criteria.getMaxTime().toMillis());
            double qualityScore = bid.getQualityScore();
            
            // Weight based on optimization goal
            return switch (criteria.getOptimizeFor()) {
                case "cost" -> 
                    costScore * 0.6 + timeScore * 0.2 + qualityScore * 0.2;
                case "time" -> 
                    costScore * 0.2 + timeScore * 0.6 + qualityScore * 0.2;
                case "quality" -> 
                    costScore * 0.2 + timeScore * 0.2 + qualityScore * 0.6;
                default -> 
                    costScore * 0.33 + timeScore * 0.33 + qualityScore * 0.34;
            };
        }
    }
    
    // Example bidding agent
    @Component
    public class TranslationAgent implements 
            ApplicationListener<TaskAuctionEvent> {
        
        private final ChatClient chatClient;
        private final TaskAuctioneer auctioneer;
        
        @Override
        public void onApplicationEvent(TaskAuctionEvent event) {
            TaskAuction auction = event.getAuction();
            
            // Only bid on translation tasks
            if (!auction.getTaskType().equals("TRANSLATION")) {
                return;
            }
            
            // Evaluate capability and submit bid
            submitBid(auction);
        }
        
        private void submitBid(TaskAuction auction) {
            TranslationTask task = 
                (TranslationTask) auction.getTaskData();
            
            // Use AI to estimate effort
            String prompt = """
                Estimate the effort for this translation task:
                
                Source language: %s
                Target language: %s
                Text length: %d words
                Domain: %s
                
                Provide JSON with:
                - estimatedMinutes: int
                - difficultyScore: 0.0 to 1.0
                - expectedQuality: 0.0 to 1.0
                """.formatted(
                    task.getSourceLang(),
                    task.getTargetLang(),
                    task.getWordCount(),
                    task.getDomain()
                );
            
            Map<String, Object> estimate = 
                parseJson(chatClient.call(prompt));
            
            // Calculate bid
            int minutes = (Integer) estimate.get("estimatedMinutes");
            double quality = (Double) estimate.get("expectedQuality");
            double cost = calculateCost(minutes, 
                task.getSourceLang(), 
                task.getTargetLang());
            
            Bid bid = Bid.builder()
                .agentId(getAgentId())
                .cost(cost)
                .estimatedTime(Duration.ofMinutes(minutes))
                .qualityScore(quality)
                .reasoning(String.format(
                    "Specialized in %s→%s translation",
                    task.getSourceLang(),
                    task.getTargetLang()
                ))
                .build();
            
            // Submit bid if it meets criteria
            if (bid.getCost() <= auction.getCriteria().getMaxCost() &&
                bid.getEstimatedTime().compareTo(
                    auction.getCriteria().getMaxTime()) <= 0) {
                
                auction.getBids().add(bid);
                log.info("Agent {} bid ${} for task {}",
                    getAgentId(), cost, auction.getTaskId());
            }
        }
        
        private double calculateCost(int minutes, 
                                     String sourceLang,
                                     String targetLang) {
            // Base rate + complexity multiplier
            double baseRate = 0.10;  // per minute
            double langPairMultiplier = 
                getLangPairMultiplier(sourceLang, targetLang);
            
            return minutes * baseRate * langPairMultiplier;
        }
        
        private String getAgentId() {
            return "translation-agent-01";
        }
    }
}
```

## Agent Communication Protocols

### Comparison of Communication Methods

| Protocol | Latency | Scalability | Use Case | Complexity |
|----------|---------|-------------|----------|------------|
| **Direct Method Calls** | Lowest | Low | Hierarchical systems | Low |
| **Event-Driven** | Low | High | Peer-to-peer, loose coupling | Medium |
| **Message Queues** | Medium | Very High | Async workflows, reliability | High |
| **Shared Memory** | Lowest | Medium | Local pipelines | Low |
| **HTTP/REST** | High | High | Distributed systems | Medium |
| **WebSockets** | Low | Medium | Real-time collaboration | Medium |

### Event-Driven Communication (Recommended)

Spring's event system provides excellent foundation for agent communication:

```java
@Configuration
public class AgentEventConfig {
    
    // Custom event types
    @Data
    @AllArgsConstructor
    public static class AgentTaskEvent extends ApplicationEvent {
        private final String taskId;
        private final String taskType;
        private final Object payload;
        private final String fromAgent;
        
        public AgentTaskEvent(Object source, String taskId, 
                             String taskType, Object payload,
                             String fromAgent) {
            super(source);
            this.taskId = taskId;
            this.taskType = taskType;
            this.payload = payload;
            this.fromAgent = fromAgent;
        }
    }
    
    @Data
    public static class AgentResponseEvent extends ApplicationEvent {
        private final String taskId;
        private final Object result;
        private final String fromAgent;
        private final boolean success;
        
        public AgentResponseEvent(Object source, String taskId,
                                 Object result, String fromAgent,
                                 boolean success) {
            super(source);
            this.taskId = taskId;
            this.result = result;
            this.fromAgent = fromAgent;
            this.success = success;
        }
    }
    
    // Async event processing
    @Bean
    public ApplicationEventMulticaster applicationEventMulticaster() {
        SimpleApplicationEventMulticaster multicaster = 
            new SimpleApplicationEventMulticaster();
        
        multicaster.setTaskExecutor(
            new SimpleAsyncTaskExecutor());
        
        return multicaster;
    }
}

@Service
public class EventDrivenAgentCoordinator {
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    private final Map<String, CompletableFuture<Object>> pendingTasks = 
        new ConcurrentHashMap<>();
    
    // Send task to agents
    public CompletableFuture<Object> delegateTask(
            String taskType,
            Object payload) {
        
        String taskId = UUID.randomUUID().toString();
        CompletableFuture<Object> future = new CompletableFuture<>();
        
        pendingTasks.put(taskId, future);
        
        // Publish event (agents will listen)
        eventPublisher.publishEvent(
            new AgentTaskEvent(
                this,
                taskId,
                taskType,
                payload,
                "coordinator"
            )
        );
        
        // Timeout after 30 seconds
        CompletableFuture.delayedExecutor(30, TimeUnit.SECONDS)
            .execute(() -> {
                if (pendingTasks.containsKey(taskId)) {
                    future.completeExceptionally(
                        new TimeoutException("Task timeout: " + taskId)
                    );
                    pendingTasks.remove(taskId);
                }
            });
        
        return future;
    }
    
    // Handle agent responses
    @EventListener
    public void handleAgentResponse(AgentResponseEvent event) {
        CompletableFuture<Object> future = 
            pendingTasks.remove(event.getTaskId());
        
        if (future != null) {
            if (event.isSuccess()) {
                future.complete(event.getResult());
            } else {
                future.completeExceptionally(
                    new RuntimeException("Agent task failed: " + 
                        event.getResult())
                );
            }
        }
    }
}
```

## Real-World Use Cases

### Use Case 1: Intelligent Customer Service System

**Architecture:**

```
┌─────────────────────────────────────────────────────────────┐
│      Multi-Agent Customer Service Architecture               │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  Customer Query                                               │
│        ↓                                                      │
│  ┌──────────────────┐                                        │
│  │ Routing Agent    │  Classifies query type                │
│  │ (GPT-4o Mini)    │  & urgency                            │
│  └────────┬─────────┘                                        │
│           │                                                   │
│           ├──→ Technical? ──→ ┌──────────────────┐          │
│           │                    │ Tech Support     │          │
│           │                    │ Agent (GPT-4o)   │          │
│           │                    └──────────────────┘          │
│           │                                                   │
│           ├──→ Billing? ───→ ┌──────────────────┐           │
│           │                   │ Billing Agent    │           │
│           │                   │ (GPT-4o + Tools) │           │
│           │                   └──────────────────┘           │
│           │                                                   │
│           ├──→ Product? ──→ ┌──────────────────┐            │
│           │                  │ Product Expert   │            │
│           │                  │ (Claude Sonnet)  │            │
│           │                  └──────────────────┘            │
│           │                                                   │
│           └──→ Complex? ──→ ┌──────────────────┐            │
│                             │ Escalation Mgr   │            │
│                             │ (Human Handoff)  │            │
│                             └──────────────────┘            │
│                                     │                         │
│                              ┌──────┴──────┐                 │
│                              │ QA Agent    │                 │
│                              │ Reviews all │                 │
│                              │ interactions│                 │
│                              └─────────────┘                 │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

**Implementation:**

```java
@Service
public class CustomerServiceAgentSystem {
    
    @Component
    public class RoutingAgent {
        
        private final ChatClient chatClient;
        
        public RouteDecision routeQuery(CustomerQuery query) {
            String prompt = """
                Classify this customer query:
                "%s"
                
                Categories:
                - TECHNICAL_SUPPORT: bugs, errors, how-to
                - BILLING: payments, invoices, refunds
                - PRODUCT_INFO: features, pricing, comparisons
                - ACCOUNT: login, profile, settings
                - ESCALATION: complaints, complex issues
                
                Return JSON with:
                - category: string
                - urgency: "low" | "medium" | "high" | "critical"
                - reasoning: brief explanation
                - suggestedAgent: agent type to handle this
                """.formatted(query.getMessage());
            
            Map<String, Object> decision = parseJson(
                chatClient.call(new Prompt(prompt,
                    ChatOptions.builder()
                        .withModel("gpt-4o-mini")  // Cheap model
                        .withResponseFormat(
                            new ResponseFormat("json_object"))
                        .build()
                ))
            );
            
            return RouteDecision.builder()
                .category((String) decision.get("category"))
                .urgency((String) decision.get("urgency"))
                .reasoning((String) decision.get("reasoning"))
                .suggestedAgent((String) decision.get("suggestedAgent"))
                .build();
        }
    }
    
    @Component
    public class TechnicalSupportAgent {
        
        private final ChatClient gpt4o;
        private final VectorStore knowledgeBase;
        
        public SupportResponse handleTechnicalQuery(
                CustomerQuery query,
                RouteDecision routing) {
            
            // Search knowledge base
            List<Document> relevantDocs = 
                knowledgeBase.similaritySearch(
                    SearchRequest.query(query.getMessage())
                        .withTopK(5)
                );
            
            // Generate response with RAG
            String prompt = """
                You are a technical support agent. Help this customer:
                
                Query: %s
                Urgency: %s
                
                Knowledge Base:
                %s
                
                Provide:
                1. Clear solution steps
                2. If applicable, link to relevant documentation
                3. If issue requires escalation, explain why
                
                Be helpful, patient, and professional.
                """.formatted(
                    query.getMessage(),
                    routing.getUrgency(),
                    formatDocs(relevantDocs)
                );
            
            String response = gpt4o.call(prompt);
            
            // Check if needs escalation
            boolean needsEscalation = detectEscalationNeed(
                query, response);
            
            return SupportResponse.builder()
                .message(response)
                .resolvedBy("TechnicalSupportAgent")
                .needsEscalation(needsEscalation)
                .referencedDocs(relevantDocs)
                .timestamp(Instant.now())
                .build();
        }
        
        private boolean detectEscalationNeed(
                CustomerQuery query,
                String response) {
            
            // Use AI to determine if escalation needed
            String prompt = """
                Based on this exchange, should it be escalated to human?
                
                Customer: %s
                Response: %s
                
                Escalate if:
                - Solution uncertain or incomplete
                - Customer seems frustrated
                - Issue is complex/critical
                - Response might need verification
                
                Return JSON: {"shouldEscalate": boolean, "reason": string}
                """.formatted(query.getMessage(), response);
            
            Map<String, Object> decision = parseJson(
                gpt4o.call(prompt));
            
            return (Boolean) decision.get("shouldEscalate");
        }
    }
    
    @Component
    public class BillingAgent {
        
        private final ChatClient chatClient;
        private final BillingService billingService;
        
        @FunctionDefinition
        public String lookupInvoice(
                @FunctionParameter(description = "Customer email") 
                String email,
                @FunctionParameter(description = "Invoice number or 'latest'") 
                String invoiceId) {
            
            return billingService.getInvoice(email, invoiceId)
                .map(Invoice::toJson)
                .orElse("Invoice not found");
        }
        
        @FunctionDefinition
        public String processRefund(
                @FunctionParameter(description = "Invoice ID") 
                String invoiceId,
                @FunctionParameter(description = "Refund amount") 
                double amount,
                @FunctionParameter(description = "Reason for refund") 
                String reason) {
            
            if (amount > 100.00) {
                return "Refund amount exceeds authorization. Escalating to manager.";
            }
            
            RefundResult result = billingService.issueRefund(
                invoiceId, amount, reason);
            
            return result.isSuccess() 
                ? "Refund processed: $" + amount 
                : "Refund failed: " + result.getError();
        }
        
        public SupportResponse handleBillingQuery(CustomerQuery query) {
            // Enable function calling
            String response = chatClient.call(
                new Prompt(
                    """
                    You are a billing support agent with access to:
                    - lookupInvoice: get invoice details
                    - processRefund: issue refunds up to $100
                    
                    Customer query: %s
                    
                    Use tools as needed. Be empathetic about billing issues.
                    """.formatted(query.getMessage()),
                    ChatOptions.builder()
                        .withFunctions(Set.of(
                            "lookupInvoice",
                            "processRefund"
                        ))
                        .build()
                )
            );
            
            return SupportResponse.builder()
                .message(response)
                .resolvedBy("BillingAgent")
                .build();
        }
    }
    
    @Component
    public class ProductExpertAgent {
        
        private final ChatClient claude;  // Claude excels at detailed explanations
        private final ProductCatalog catalog;
        
        public SupportResponse handleProductQuery(CustomerQuery query) {
            // Get product context
            List<Product> relevantProducts = 
                catalog.search(query.getMessage());
            
            String prompt = """
                You are a product expert. Help this customer understand
                our products:
                
                Question: %s
                
                Relevant products:
                %s
                
                Provide:
                - Clear, detailed explanation
                - Comparisons if asked
                - Use cases and examples
                - Pricing transparency
                - Honest about limitations
                
                Be enthusiastic but authentic. Don't oversell.
                """.formatted(
                    query.getMessage(),
                    formatProducts(relevantProducts)
                );
            
            String response = claude.call(prompt);
            
            return SupportResponse.builder()
                .message(response)
                .resolvedBy("ProductExpertAgent")
                .productsReferenced(relevantProducts)
                .build();
        }
    }
    
    @Component
    public class QualityAssuranceAgent {
        
        private final ChatClient chatClient;
        
        public QAAssessment reviewInteraction(
                CustomerQuery query,
                SupportResponse response) {
            
            String prompt = """
                Review this customer service interaction:
                
                Customer: %s
                Agent Response: %s
                Handled By: %s
                
                Assess:
                1. Accuracy (0-100): Was the response correct?
                2. Completeness (0-100): Fully addressed the query?
                3. Tone (0-100): Professional and empathetic?
                4. Timeliness (0-100): Appropriate response time?
                
                Return JSON with scores and feedback.
                """.formatted(
                    query.getMessage(),
                    response.getMessage(),
                    response.getResolvedBy()
                );
            
            Map<String, Object> assessment = parseJson(
                chatClient.call(prompt));
            
            // Log for training/improvement
            logQAAssessment(query, response, assessment);
            
            return QAAssessment.fromMap(assessment);
        }
    }
    
    // Orchestrator
    @Service
    public class CustomerServiceOrchestrator {
        
        private final RoutingAgent routingAgent;
        private final Map<String, Object> specializingAgents;
        private final QualityAssuranceAgent qaAgent;
        
        public ServiceResult handleCustomerQuery(CustomerQuery query) {
            // Stage 1: Route
            RouteDecision routing = routingAgent.routeQuery(query);
            
            // Stage 2: Handle with appropriate agent
            SupportResponse response = switch (routing.getCategory()) {
                case "TECHNICAL_SUPPORT" -> 
                    technicalSupportAgent.handleTechnicalQuery(
                        query, routing);
                case "BILLING" -> 
                    billingAgent.handleBillingQuery(query);
                case "PRODUCT_INFO" -> 
                    productExpertAgent.handleProductQuery(query);
                case "ESCALATION" -> 
                    escalationAgent.escalateToHuman(query);
                default -> 
                    generalAgent.handleGenericQuery(query);
            };
            
            // Stage 3: Quality check
            QAAssessment qa = qaAgent.reviewInteraction(query, response);
            
            // Stage 4: Escalate if needed or QA flagged issues
            if (response.isNeedsEscalation() || qa.getOverallScore() < 70) {
                response = escalationAgent.escalateToHuman(query);
            }
            
            return ServiceResult.builder()
                .query(query)
                .response(response)
                .routing(routing)
                .qaAssessment(qa)
                .build();
        }
    }
}
```

**Performance Metrics:**

| Metric | Single Agent | Multi-Agent | Improvement |
|--------|--------------|-------------|-------------|
| **Average Resolution Time** | 2.5 min | 1.8 min | 28% faster |
| **Customer Satisfaction** | 3.8/5 | 4.5/5 | 18% higher |
| **Cost per Query** | $0.15 | $0.08 | 47% cheaper |
| **First Contact Resolution** | 65% | 82% | 17% higher |
| **Escalation Rate** | 25% | 12% | 52% lower |

### Use Case 2: Content Creation Pipeline

**Requirements:** Generate high-quality blog posts with research, writing, editing, SEO optimization, and fact-checking.

```java
@Service
public class ContentCreationPipeline {
    
    @Component
    @Order(1)
    public class ResearchAgent implements PipelineStage {
        
        private final ChatClient chatClient;
        private final WebSearchTool webSearch;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            ContentRequest request = 
                (ContentRequest) context.getPayload();
            
            // Web research
            List<SearchResult> searchResults = 
                webSearch.search(request.getTopic(), 20);
            
            // Synthesize findings
            String prompt = """
                Research this topic: %s
                
                Search results:
                %s
                
                Provide:
                1. Key points and themes (5-7 main ideas)
                2. Important statistics and data
                3. Expert quotes and opinions
                4. Current trends
                5. Controversial or debated aspects
                6. Gaps in existing content
                
                Target audience: %s
                """.formatted(
                    request.getTopic(),
                    formatSearchResults(searchResults),
                    request.getAudience()
                );
            
            String research = chatClient.call(prompt);
            
            context.addData("research", research);
            context.addData("sources", searchResults);
            
            return context;
        }
        
        @Override
        public String getStageName() {
            return "Research";
        }
        
        @Override
        public int getOrder() {
            return 1;
        }
    }
    
    @Component
    @Order(2)
    public class OutlineAgent implements PipelineStage {
        
        private final ChatClient chatClient;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            String research = (String) context.getData("research");
            ContentRequest request = 
                (ContentRequest) context.getPayload();
            
            String prompt = """
                Create a detailed outline for a blog post:
                
                Topic: %s
                Target length: %d words
                Audience: %s
                
                Research:
                %s
                
                Requirements:
                - Compelling headline (H1)
                - Introduction hook
                - 5-7 main sections (H2) with subsections (H3)
                - Conclusion with CTA
                - Logical flow and transitions
                
                Format as hierarchical outline.
                """.formatted(
                    request.getTopic(),
                    request.getTargetWords(),
                    request.getAudience(),
                    research
                );
            
            String outline = chatClient.call(prompt);
            
            context.addData("outline", outline);
            
            return context;
        }
        
        @Override
        public String getStageName() {
            return "Outline";
        }
        
        @Override
        public int getOrder() {
            return 2;
        }
    }
    
    @Component
    @Order(3)
    public class WritingAgent implements PipelineStage {
        
        private final ChatClient claude;  // Claude for creative writing
        
        @Override
        public PipelineContext process(PipelineContext context) {
            String outline = (String) context.getData("outline");
            String research = (String) context.getData("research");
            
            String prompt = """
                Write a complete blog post following this outline:
                
                %s
                
                Use this research:
                %s
                
                Requirements:
                - Engaging, conversational tone
                - Clear explanations of complex topics
                - Specific examples and analogies
                - Smooth transitions
                - Strong introduction and conclusion
                - Natural keyword integration
                
                Write the full article now.
                """.formatted(outline, research);
            
            String draft = claude.call(
                new Prompt(prompt, ChatOptions.builder()
                    .withTemperature(0.8)
                    .withMaxTokens(4000)
                    .build())
            );
            
            context.addData("draft", draft);
            
            return context;
        }
        
        @Override
        public String getStageName() {
            return "Writing";
        }
        
        @Override
        public int getOrder() {
            return 3;
        }
    }
    
    @Component
    @Order(4)
    public class FactCheckAgent implements PipelineStage {
        
        private final ChatClient chatClient;
        private final WebSearchTool webSearch;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            String draft = (String) context.getData("draft");
            
            // Extract claims
            String extractPrompt = """
                Extract all factual claims from this article:
                
                %s
                
                Return JSON array of claims with:
                - claim: the statement
                - category: "statistic" | "fact" | "quote" | "date"
                """.formatted(draft);
            
            List<Map<String, String>> claims = parseJsonArray(
                chatClient.call(extractPrompt));
            
            // Verify each claim
            List<FactCheckResult> results = claims.stream()
                .map(claim -> verifyFact(
                    claim.get("claim"),
                    claim.get("category")
                ))
                .collect(Collectors.toList());
            
            // Flag issues
            List<FactCheckResult> issues = results.stream()
                .filter(r -> !r.isVerified())
                .collect(Collectors.toList());
            
            context.addData("factCheckResults", results);
            context.addData("factCheckIssues", issues);
            
            if (!issues.isEmpty()) {
                context.addFlag("FACT_CHECK_FAILURES");
            }
            
            return context;
        }
        
        private FactCheckResult verifyFact(String claim, String category) {
            // Search for verification
            List<SearchResult> results = webSearch.search(claim, 5);
            
            String verifyPrompt = """
                Verify this claim:
                "%s"
                
                Search results:
                %s
                
                Is it accurate? Return JSON:
                {
                  "verified": boolean,
                  "confidence": 0.0-1.0,
                  "sources": [array of URLs],
                  "correction": "corrected version if wrong"
                }
                """.formatted(claim, formatSearchResults(results));
            
            Map<String, Object> verification = parseJson(
                chatClient.call(verifyPrompt));
            
            return FactCheckResult.fromMap(verification);
        }
        
        @Override
        public String getStageName() {
            return "Fact Checking";
        }
        
        @Override
        public int getOrder() {
            return 4;
        }
    }
    
    @Component
    @Order(5)
    public class EditingAgent implements PipelineStage {
        
        private final ChatClient chatClient;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            String draft = (String) context.getData("draft");
            List<FactCheckResult> issues = 
                (List<FactCheckResult>) context.getData("factCheckIssues");
            
            String prompt = """
                Edit this draft for publication:
                
                %s
                
                Fact-check corrections needed:
                %s
                
                Edit for:
                1. Grammar, spelling, punctuation
                2. Clarity and readability
                3. Consistent tone and style
                4. Remove redundancy
                5. Improve flow
                6. Incorporate fact-check corrections
                
                Return polished final version.
                """.formatted(
                    draft,
                    formatFactCheckIssues(issues)
                );
            
            String finalContent = chatClient.call(prompt);
            
            context.addData("finalContent", finalContent);
            
            return context;
        }
        
        @Override
        public String getStageName() {
            return "Editing";
        }
        
        @Override
        public int getOrder() {
            return 5;
        }
    }
    
    @Component
    @Order(6)
    public class SEOAgent implements PipelineStage {
        
        private final ChatClient chatClient;
        
        @Override
        public PipelineContext process(PipelineContext context) {
            String content = (String) context.getData("finalContent");
            ContentRequest request = 
                (ContentRequest) context.getPayload();
            
            String prompt = """
                Optimize this content for SEO:
                
                %s
                
                Target keywords: %s
                
                Generate:
                1. SEO title (55-60 chars)
                2. Meta description (150-160 chars)
                3. URL slug
                4. H1 tag
                5. Image alt text suggestions
                6. Internal linking opportunities
                7. Schema markup recommendations
                
                Return as JSON.
                """.formatted(
                    content,
                    request.getKeywords()
                );
            
            Map<String, Object> seoData = parseJson(
                chatClient.call(prompt));
            
            context.addData("seoMetadata", seoData);
            
            return context;
        }
        
        @Override
        public String getStageName() {
            return "SEO Optimization";
        }
        
        @Override
        public int getOrder() {
            return 6;
        }
    }
}
```

**Pipeline Execution:**

```java
@Service
public class ContentPipelineOrchestrator {
    
    private final List<PipelineStage> stages;
    
    public BlogPost createContent(ContentRequest request) {
        PipelineContext context = PipelineContext.builder()
            .payload(request)
            .build();
        
        // Execute pipeline
        for (PipelineStage stage : stages) {
            log.info("Executing: {}", stage.getStageName());
            Instant start = Instant.now();
            
            context = stage.process(context);
            
            Duration duration = Duration.between(start, Instant.now());
            log.info("{} completed in {}ms",
                stage.getStageName(),
                duration.toMillis());
        }
        
        // Compile final result
        return BlogPost.builder()
            .content((String) context.getData("finalContent"))
            .seoMetadata((Map) context.getData("seoMetadata"))
            .sources((List) context.getData("sources"))
            .factCheckResults((List) context.getData("factCheckResults"))
            .processingTime(context.getTotalDuration())
            .build();
    }
}
```

## Advanced Coordination Patterns

### Consensus-Based Decision Making

Multiple agents vote on decisions:

```java
@Service
public class ConsensusCoordinator {
    
    @Data
    @Builder
    public static class ConsensusRequest {
        private String question;
        private List<String> options;
        private double requiredAgreement;  // 0.0-1.0
    }
    
    @Data
    @Builder
    public static class AgentVote {
        private String agentId;
        private String choice;
        private double confidence;
        private String reasoning;
    }
    
    public ConsensusResult achieveConsensus(
            ConsensusRequest request,
            List<Agent> agents) {
        
        // Collect votes from all agents
        List<AgentVote> votes = agents.parallelStream()
            .map(agent -> agent.vote(request))
            .collect(Collectors.toList());
        
        // Analyze votes
        Map<String, List<AgentVote>> votesByChoice = votes.stream()
            .collect(Collectors.groupingBy(AgentVote::getChoice));
        
        // Find majority
        Optional<Map.Entry<String, List<AgentVote>>> majority = 
            votesByChoice.entrySet().stream()
                .max(Comparator.comparingInt(e -> e.getValue().size()));
        
        if (majority.isEmpty()) {
            return ConsensusResult.noConsensus();
        }
        
        // Check if meets threshold
        double agreement = majority.get().getValue().size() / 
            (double) votes.size();
        
        if (agreement >= request.getRequiredAgreement()) {
            return ConsensusResult.builder()
                .consensusReached(true)
                .decision(majority.get().getKey())
                .agreement(agreement)
                .votes(votes)
                .build();
        }
        
        // If no consensus, escalate or iterate
        return handleDisagreement(request, votes, agents);
    }
    
    private ConsensusResult handleDisagreement(
            ConsensusRequest request,
            List<AgentVote> votes,
            List<Agent> agents) {
        
        // Use mediator agent to resolve
        MediatorAgent mediator = new MediatorAgent(chatClient);
        
        String resolution = mediator.mediate(request, votes);
        
        return ConsensusResult.builder()
            .consensusReached(false)
            .mediatedDecision(resolution)
            .votes(votes)
            .build();
    }
}
```

### Load Balancing Across Agents

```java
@Service
public class AgentLoadBalancer {
    
    private final Map<String, AgentMetrics> agentMetrics = 
        new ConcurrentHashMap<>();
    
    @Data
    public static class AgentMetrics {
        private String agentId;
        private AtomicInteger activeTasks = new AtomicInteger(0);
        private AtomicLong totalProcessingTime = new AtomicLong(0);
        private AtomicInteger completedTasks = new AtomicInteger(0);
        private AtomicInteger failedTasks = new AtomicInteger(0);
        
        public double getAverageProcessingTime() {
            int completed = completedTasks.get();
            return completed > 0 
                ? totalProcessingTime.get() / (double) completed 
                : 0;
        }
        
        public double getSuccessRate() {
            int total = completedTasks.get() + failedTasks.get();
            return total > 0 
                ? completedTasks.get() / (double) total 
                : 1.0;
        }
        
        public double getLoadScore() {
            // Lower is better
            return activeTasks.get() * getAverageProcessingTime() 
                / getSuccessRate();
        }
    }
    
    public Agent selectAgent(List<Agent> availableAgents) {
        // Find agent with lowest load score
        return availableAgents.stream()
            .min(Comparator.comparingDouble(agent -> 
                getMetrics(agent.getAgentId()).getLoadScore()))
            .orElseThrow(() -> 
                new NoAvailableAgentsException());
    }
    
    public <T> CompletableFuture<T> executeWithLoadBalancing(
            List<Agent> agents,
            Function<Agent, T> task) {
        
        Agent selectedAgent = selectAgent(agents);
        AgentMetrics metrics = getMetrics(selectedAgent.getAgentId());
        
        metrics.activeTasks.incrementAndGet();
        Instant start = Instant.now();
        
        return CompletableFuture.supplyAsync(() -> {
            try {
                T result = task.apply(selectedAgent);
                
                // Update metrics on success
                long duration = Duration.between(start, Instant.now())
                    .toMillis();
                metrics.totalProcessingTime.addAndGet(duration);
                metrics.completedTasks.incrementAndGet();
                
                return result;
                
            } catch (Exception e) {
                metrics.failedTasks.incrementAndGet();
                throw new RuntimeException(e);
                
            } finally {
                metrics.activeTasks.decrementAndGet();
            }
        });
    }
    
    private AgentMetrics getMetrics(String agentId) {
        return agentMetrics.computeIfAbsent(
            agentId,
            id -> new AgentMetrics()
        );
    }
}
```

## Monitoring & Observability

### Comprehensive Agent Metrics

```java
@Configuration
public class AgentObservabilityConfig {
    
    @Bean
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }
}

@Aspect
@Component
public class AgentMetricsCollector {
    
    private final MeterRegistry registry;
    
    @Around("@annotation(AgentTask)")
    public Object collectMetrics(ProceedingJoinPoint joinPoint) 
            throws Throwable {
        
        String agentId = extractAgentId(joinPoint);
        String taskType = extractTaskType(joinPoint);
        
        Timer.Sample sample = Timer.start(registry);
        
        try {
            Object result = joinPoint.proceed();
            
            // Record success
            sample.stop(registry.timer("agent.task.duration",
                "agent", agentId,
                "task", taskType,
                "status", "success"
            ));
            
            registry.counter("agent.task.completed",
                "agent", agentId,
                "task", taskType
            ).increment();
            
            // Track result size if applicable
            if (result instanceof String) {
                registry.summary("agent.response.length",
                    "agent", agentId
                ).record(((String) result).length());
            }
            
            return result;
            
        } catch (Exception e) {
            // Record failure
            sample.stop(registry.timer("agent.task.duration",
                "agent", agentId,
                "task", taskType,
                "status", "error"
            ));
            
            registry.counter("agent.task.failed",
                "agent", agentId,
                "task", taskType,
                "error", e.getClass().getSimpleName()
            ).increment();
            
            throw e;
        }
    }
}

@RestController
@RequestMapping("/admin/agents")
public class AgentMonitoringController {
    
    private final MeterRegistry registry;
    private final AgentLoadBalancer loadBalancer;
    
    @GetMapping("/metrics")
    public Map<String, Object> getAgentMetrics() {
        Map<String, Object> metrics = new HashMap<>();
        
        // Aggregate metrics by agent
        registry.getMeters().stream()
            .filter(meter -> meter.getId().getName()
                .startsWith("agent."))
            .forEach(meter -> {
                String agentId = meter.getId().getTag("agent");
                
                metrics.computeIfAbsent(agentId, 
                    k -> new HashMap<String, Object>());
                
                Map<String, Object> agentMetrics = 
                    (Map<String, Object>) metrics.get(agentId);
                
                if (meter instanceof Timer) {
                    Timer timer = (Timer) meter;
                    agentMetrics.put("avgDuration", 
                        timer.mean(TimeUnit.MILLISECONDS));
                    agentMetrics.put("maxDuration", 
                        timer.max(TimeUnit.MILLISECONDS));
                    agentMetrics.put("count", timer.count());
                } else if (meter instanceof Counter) {
                    Counter counter = (Counter) meter;
                    agentMetrics.put(meter.getId().getName(), 
                        counter.count());
                }
            });
        
        return metrics;
    }
    
    @GetMapping("/health")
    public Map<String, AgentHealth> getAgentHealth() {
        // Check health of each agent
        Map<String, AgentHealth> health = new HashMap<>();
        
        loadBalancer.getAllMetrics().forEach((agentId, metrics) -> {
            AgentHealth agentHealth = AgentHealth.builder()
                .agentId(agentId)
                .activeTasks(metrics.getActiveTasks().get())
                .successRate(metrics.getSuccessRate())
                .avgResponseTime(metrics.getAverageProcessingTime())
                .status(determineStatus(metrics))
                .build();
            
            health.put(agentId, agentHealth);
        });
        
        return health;
    }
    
    private HealthStatus determineStatus(AgentMetrics metrics) {
        if (metrics.getSuccessRate() < 0.9) {
            return HealthStatus.UNHEALTHY;
        }
        if (metrics.getActiveTasks().get() > 10) {
            return HealthStatus.DEGRADED;
        }
        return HealthStatus.HEALTHY;
    }
}
```

## Best Practices & Lessons Learned

### Design Principles

**1. Single Responsibility Per Agent**

Each agent should have one clear role. Don't create "kitchen sink" agents.

✅ Good:
```java
@Component
public class EmailWritingAgent {
    // Only writes emails
}

@Component
public class EmailValidationAgent {
    // Only validates emails
}
```

❌ Bad:
```java
@Component
public class EmailAgent {
    // Writes, validates, sends, tracks, analyzes...
    // Too many responsibilities
}
```

**2. Explicit Communication Contracts**

Define clear interfaces for agent communication:

```java
public interface AgentMessage {
    String getMessageType();
    Object getPayload();
    String getCorrelationId();
}

public interface Agent {
    boolean canHandle(AgentMessage message);
    AgentResponse handle(AgentMessage message);
}
```

**3. Graceful Degradation**

Always have fallback strategies:

```java
public String robustAgentCall(List<Agent> agents, Task task) {
    for (Agent agent : agents) {
        try {
            return agent.execute(task);
        } catch (Exception e) {
            log.warn("Agent {} failed, trying next", 
                agent.getId());
        }
    }
    
    // Final fallback
    return simpleRuleBasedFallback(task);
}
```

**4. Idempotency**

Agent operations should be idempotent where possible:

```java
@AgentTask
@Idempotent(key = "#taskId")
public Result processTask(String taskId, TaskData data) {
    // This can be safely retried
}
```

**5. Observable Interactions**

Log all agent interactions for debugging:

```java
@Aspect
@Component
public class AgentInteractionLogger {
    
    @Around("execution(* *Agent.*(..))")
    public Object logInteraction(ProceedingJoinPoint joinPoint) {
        String agentName = extractAgentName(joinPoint);
        String method = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        
        log.info("Agent: {} | Method: {} | Args: {}",
            agentName, method, summarizeArgs(args));
        
        try {
            Object result = joinPoint.proceed();
            log.info("Agent: {} | Result: {}",
                agentName, summarizeResult(result));
            return result;
        } catch (Exception e) {
            log.error("Agent: {} | Error: {}",
                agentName, e.getMessage());
            throw e;
        }
    }
}
```

## Conclusion

Multi-agent systems represent the evolution of AI applications from monolithic to distributed intelligence. By coordinating specialized agents, you can:

- **Optimize Costs**: Route tasks to appropriately priced models
- **Improve Quality**: Leverage specialist agents for their strengths
- **Increase Reliability**: Build fault-tolerant systems with redundancy
- **Scale Efficiently**: Add capacity by deploying more agents
- **Enhance Auditability**: Track decisions through agent chains

Spring AI provides the perfect foundation for building production-grade multi-agent systems, offering:
- Consistent abstractions across models
- Enterprise integration patterns
- Comprehensive observability
- Spring ecosystem compatibility

Start simple with hierarchical patterns, measure everything, and evolve to more sophisticated coordination as your requirements grow.

The future of AI applications is collaborative intelligence. Master multi-agent systems now to stay ahead.

---

**Resources:**

- [Spring AI Documentation](https://docs.spring.io/spring-ai/reference/)
- [Multi-Agent Systems: A Survey](https://arxiv.org/abs/2401.03428)
- [Agent Communication Patterns](https://www.fipa.org/specs/)
- [Spring Events Guide](https://spring.io/guides/gs/event-driven)